# Fill with minuses
# (this is recalculated every time the prompt is shown in function prompt_command):
fill="--- "

reset_style='\[\033[00m\]'
if [ -z "$VIM" ];
	then status_style=$reset_style'\[\033[0;90m\]' # gray color; use 0;37m for lighter color
	else status_style=$reset_style'\[\033[0;90;107m\]'
fi
prompt_style=$reset_style
command_style=$reset_style'\[\033[1;29m\]' # bold black
# Prompt variable:

OLD_PS1="$PS1"
PS1="$status_style"'$fill \t\n'"$prompt_style\`parse_git_branch\`$OLD_PS1$command_style"

# Reset color for command output
# (this one is invoked every time before a command is executed):
trap 'echo -ne "\e[0m"' DEBUG


function prompt_command {

	# create a $fill of all screen width minus the time string and a space:
	let fillsize=${COLUMNS}-9
	fill=""
	while [ "$fillsize" -gt "0" ]
	do
		fill="-${fill}" # fill with underscores to work on 
		let fillsize=${fillsize}-1
	done

	# If this is an xterm set the title to user@host:dir
	case "$TERM" in
	xterm*|rxvt*)
		bname=`basename "${PWD/$HOME/~}"`
		echo -ne "\033]0;${bname}: ${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007"
		;;
	*)
		;;
	esac
}
PROMPT_COMMAND=prompt_command

# get current branch in git repo
function parse_git_branch() {
	BRANCH=`git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'`
	if [ ! "${BRANCH}" == "" ]
	then
		STAT=`parse_git_dirty`
		echo -e "(${BRANCH}${STAT})\n \b"
	else
		echo ""
	fi
}

# get current status of git repo
function parse_git_dirty {
	BRANCH=`git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'`
	bits=''

	if commits=$(git rev-list --left-right origin/${BRANCH}..HEAD 2>/dev/null)
	then
		local commit behind=0 ahead=0
		for commit in $commits
		do
			case "$commit" in
				"<"*) ((behind++)) ;;
				*)    ((ahead++))  ;;
			esac
		done
		if [ $behind -eq 0 -a $ahead -eq 0 ]; then
			bits="${bits} ="
		elif [ $behind -gt 0 -a $ahead -gt 0 ]; then
			bits="${bits} <${behind} >${ahead}"
		elif [ $behind -gt 0 -a $ahead -eq 0 ]; then
			bits="${bits} <${behind}"
		elif [ $behind -eq 0 -a $ahead -gt 0 ]; then
			bits="${bits} >${ahead}"
		else
			bits="${bits} **"
		fi
	fi

	status=`git status 2>&1 | tee`
	added=`git status --porcelain 2>/dev/null| grep -E "^M|^A" | wc -l`
	staged=`git status --porcelain 2>/dev/null| grep "^ M" | wc -l`
	untracked=`git ls-files --others --exclude-standard | wc -l`

	modified=`echo -n "${status}" 2> /dev/null | grep "modified:" | wc -l`
	renamed=`echo -n "${status}" 2> /dev/null | grep "renamed:" | wc -l`
	newfile=`echo -n "${status}" 2> /dev/null | grep "new file:" | wc -l`
	bothadded=`echo -n "${status}" 2> /dev/null | grep "both added:" | wc -l`
	newfile=$(($newfile+$untracked+$bothadded))
	deleted=`echo -n "${status}" 2> /dev/null | grep "deleted:" | wc -l`

	bits="${bits} +${added}"
	bits="${bits} #${staged}"
	if [ "${untracked}" != "0" ]; then
		bits="${bits} ?${untracked}"
	fi

	if [ "${modified}" != "0" ]; then
		bits="${bits} ${modified}M"
	fi
	if [ "${renamed}" != "0" ]; then
		bits="${bits} ${renamed}R"
	fi
	if [ "${newfile}" != "0" ]; then
		bits="${bits} ${newfile}N"
	fi
	if [ "${deleted}" != "0" ]; then
		bits="${bits} ${deleted}D"
	fi
	if [ ! "${bits}" == "" ]; then
		echo "${bits}"
	else
		echo ""
	fi
}
